/**
 * Dockstore API
 * This describes the dockstore API, a webservice that manages pairs of Docker images and associated metadata such as CWL documents and Dockerfiles used to build those images
 *
 * OpenAPI spec version: 1.3.0
 * Contact: theglobalalliance@genomicsandhealth.org
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { Metadata } from '../model/metadata';
import { Tool } from '../model/tool';
import { ToolClass } from '../model/toolClass';
import { ToolContainerfile } from '../model/toolContainerfile';
import { ToolDescriptor } from '../model/toolDescriptor';
import { ToolFile } from '../model/toolFile';
import { ToolTests } from '../model/toolTests';
import { ToolVersion } from '../model/toolVersion';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class GA4GHService {

    protected basePath = 'https://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Return some metadata that is useful for describing this registry
     * Return some metadata that is useful for describing this registry
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public metadataGet(observe?: 'body', reportProgress?: boolean): Observable<Metadata>;
    public metadataGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Metadata>>;
    public metadataGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Metadata>>;
    public metadataGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/plain'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Metadata>(`${this.basePath}/api/ga4gh/v2/metadata`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all tool types
     * This endpoint returns all tool-classes available 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolClassesGet(observe?: 'body', reportProgress?: boolean): Observable<Array<ToolClass>>;
    public toolClassesGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ToolClass>>>;
    public toolClassesGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ToolClass>>>;
    public toolClassesGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/plain'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<ToolClass>>(`${this.basePath}/api/ga4gh/v2/toolClasses`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all tools
     * This endpoint returns all tools available or a filtered subset using metadata query parameters. 
     * @param id A unique identifier of the tool, scoped to this registry, for example &#x60;123456&#x60;
     * @param registry The image registry that contains the image.
     * @param organization The organization in the registry that published the image.
     * @param name The name of the image.
     * @param toolname The name of the tool.
     * @param description The description of the tool.
     * @param author The author of the tool (TODO a thought occurs, are we assuming that the author of the CWL and the image are the same?).
     * @param offset Start index of paging. Pagination results can be based on numbers or other values chosen by the registry implementor (for example, SHA values). If this exceeds the current result set return an empty set.  If not specified in the request, this will start at the beginning of the results.
     * @param limit Amount of records to return in a given page.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolsGet(id?: string, registry?: string, organization?: string, name?: string, toolname?: string, description?: string, author?: string, offset?: string, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<Tool>>;
    public toolsGet(id?: string, registry?: string, organization?: string, name?: string, toolname?: string, description?: string, author?: string, offset?: string, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Tool>>>;
    public toolsGet(id?: string, registry?: string, organization?: string, name?: string, toolname?: string, description?: string, author?: string, offset?: string, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Tool>>>;
    public toolsGet(id?: string, registry?: string, organization?: string, name?: string, toolname?: string, description?: string, author?: string, offset?: string, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (id !== undefined) {
            queryParameters = queryParameters.set('id', <any>id);
        }
        if (registry !== undefined) {
            queryParameters = queryParameters.set('registry', <any>registry);
        }
        if (organization !== undefined) {
            queryParameters = queryParameters.set('organization', <any>organization);
        }
        if (name !== undefined) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (toolname !== undefined) {
            queryParameters = queryParameters.set('toolname', <any>toolname);
        }
        if (description !== undefined) {
            queryParameters = queryParameters.set('description', <any>description);
        }
        if (author !== undefined) {
            queryParameters = queryParameters.set('author', <any>author);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/plain'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<Tool>>(`${this.basePath}/api/ga4gh/v2/tools`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List one specific tool, acts as an anchor for self references
     * This endpoint returns one specific tool (which has ToolVersions nested inside it)
     * @param id A unique identifier of the tool, scoped to this registry, for example &#x60;123456&#x60;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolsIdGet(id: string, observe?: 'body', reportProgress?: boolean): Observable<Tool>;
    public toolsIdGet(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tool>>;
    public toolsIdGet(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tool>>;
    public toolsIdGet(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling toolsIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/plain'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Tool>(`${this.basePath}/api/ga4gh/v2/tools/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List versions of a tool
     * Returns all versions of the specified tool
     * @param id A unique identifier of the tool, scoped to this registry, for example &#x60;123456&#x60;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolsIdVersionsGet(id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ToolVersion>>;
    public toolsIdVersionsGet(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ToolVersion>>>;
    public toolsIdVersionsGet(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ToolVersion>>>;
    public toolsIdVersionsGet(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling toolsIdVersionsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/plain'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<ToolVersion>>(`${this.basePath}/api/ga4gh/v2/tools/${encodeURIComponent(String(id))}/versions`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the container specification(s) for the specified image.
     * Returns the container specifications(s) for the specified image. For example, a CWL CommandlineTool can be associated with one specification for a container, a CWL Workflow can be associated with multiple specifications for containers
     * @param id A unique identifier of the tool, scoped to this registry, for example &#x60;123456&#x60;
     * @param version_id An identifier of the tool version for this particular tool registry, for example &#x60;v1&#x60;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolsIdVersionsVersionIdContainerfileGet(id: string, version_id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ToolContainerfile>>;
    public toolsIdVersionsVersionIdContainerfileGet(id: string, version_id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ToolContainerfile>>>;
    public toolsIdVersionsVersionIdContainerfileGet(id: string, version_id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ToolContainerfile>>>;
    public toolsIdVersionsVersionIdContainerfileGet(id: string, version_id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling toolsIdVersionsVersionIdContainerfileGet.');
        }
        if (version_id === null || version_id === undefined) {
            throw new Error('Required parameter version_id was null or undefined when calling toolsIdVersionsVersionIdContainerfileGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/plain'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<ToolContainerfile>>(`${this.basePath}/api/ga4gh/v2/tools/${encodeURIComponent(String(id))}/versions/${encodeURIComponent(String(version_id))}/containerfile`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List one specific tool version, acts as an anchor for self references
     * This endpoint returns one specific tool version
     * @param id A unique identifier of the tool, scoped to this registry, for example &#x60;123456&#x60;
     * @param version_id An identifier of the tool version, scoped to this registry, for example &#x60;v1&#x60;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolsIdVersionsVersionIdGet(id: string, version_id: string, observe?: 'body', reportProgress?: boolean): Observable<ToolVersion>;
    public toolsIdVersionsVersionIdGet(id: string, version_id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ToolVersion>>;
    public toolsIdVersionsVersionIdGet(id: string, version_id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ToolVersion>>;
    public toolsIdVersionsVersionIdGet(id: string, version_id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling toolsIdVersionsVersionIdGet.');
        }
        if (version_id === null || version_id === undefined) {
            throw new Error('Required parameter version_id was null or undefined when calling toolsIdVersionsVersionIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/plain'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<ToolVersion>(`${this.basePath}/api/ga4gh/v2/tools/${encodeURIComponent(String(id))}/versions/${encodeURIComponent(String(version_id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the tool descriptor for the specified tool
     * Returns the descriptor for the specified tool (examples include CWL, WDL, or Nextflow documents).
     * @param type The output type of the descriptor. If not specified, it is up to the underlying implementation to determine which output type to return. Plain types return the bare descriptor while the \&quot;non-plain\&quot; types return a descriptor wrapped with metadata. Allowable values include \&quot;CWL\&quot;, \&quot;WDL\&quot;, \&quot;NFL\&quot;, \&quot;PLAIN_CWL\&quot;, \&quot;PLAIN_WDL\&quot;, \&quot;PLAIN_NFL\&quot;.
     * @param id A unique identifier of the tool, scoped to this registry, for example &#x60;123456&#x60;
     * @param version_id An identifier of the tool version, scoped to this registry, for example &#x60;v1&#x60;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolsIdVersionsVersionIdTypeDescriptorGet(type: string, id: string, version_id: string, observe?: 'body', reportProgress?: boolean): Observable<ToolDescriptor>;
    public toolsIdVersionsVersionIdTypeDescriptorGet(type: string, id: string, version_id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ToolDescriptor>>;
    public toolsIdVersionsVersionIdTypeDescriptorGet(type: string, id: string, version_id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ToolDescriptor>>;
    public toolsIdVersionsVersionIdTypeDescriptorGet(type: string, id: string, version_id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling toolsIdVersionsVersionIdTypeDescriptorGet.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling toolsIdVersionsVersionIdTypeDescriptorGet.');
        }
        if (version_id === null || version_id === undefined) {
            throw new Error('Required parameter version_id was null or undefined when calling toolsIdVersionsVersionIdTypeDescriptorGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/plain'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<ToolDescriptor>(`${this.basePath}/api/ga4gh/v2/tools/${encodeURIComponent(String(id))}/versions/${encodeURIComponent(String(version_id))}/${encodeURIComponent(String(type))}/descriptor`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get additional tool descriptor files relative to the main file
     * Descriptors can often include imports that refer to additional descriptors. This returns additional descriptors for the specified tool in the same or other directories that can be reached as a relative path. This endpoint can be useful for workflow engine implementations like cwltool to programmatically download all the descriptors for a tool and run it
     * @param type The output type of the descriptor. If not specified, it is up to the underlying implementation to determine which output type to return. Plain types return the bare descriptor while the \&quot;non-plain\&quot; types return a descriptor wrapped with metadata. Allowable values are \&quot;CWL\&quot;, \&quot;WDL\&quot;, \&quot;NFL\&quot;, \&quot;PLAIN_CWL\&quot;, \&quot;PLAIN_WDL\&quot;, \&quot;PLAIN_NFL\&quot;.
     * @param id A unique identifier of the tool, scoped to this registry, for example &#x60;123456&#x60;
     * @param version_id An identifier of the tool version for this particular tool registry, for example &#x60;v1&#x60;
     * @param relative_path A relative path to the additional file (same directory or subdirectories), for example &#39;foo.cwl&#39; would return a &#39;foo.cwl&#39; from the same directory as the main descriptor. &#39;nestedDirectory/foo.cwl&#39; would return the file  from a nested subdirectory
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolsIdVersionsVersionIdTypeDescriptorRelativePathGet(type: string, id: string, version_id: string, relative_path: string, observe?: 'body', reportProgress?: boolean): Observable<ToolDescriptor>;
    public toolsIdVersionsVersionIdTypeDescriptorRelativePathGet(type: string, id: string, version_id: string, relative_path: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ToolDescriptor>>;
    public toolsIdVersionsVersionIdTypeDescriptorRelativePathGet(type: string, id: string, version_id: string, relative_path: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ToolDescriptor>>;
    public toolsIdVersionsVersionIdTypeDescriptorRelativePathGet(type: string, id: string, version_id: string, relative_path: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling toolsIdVersionsVersionIdTypeDescriptorRelativePathGet.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling toolsIdVersionsVersionIdTypeDescriptorRelativePathGet.');
        }
        if (version_id === null || version_id === undefined) {
            throw new Error('Required parameter version_id was null or undefined when calling toolsIdVersionsVersionIdTypeDescriptorRelativePathGet.');
        }
        if (relative_path === null || relative_path === undefined) {
            throw new Error('Required parameter relative_path was null or undefined when calling toolsIdVersionsVersionIdTypeDescriptorRelativePathGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/plain'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<ToolDescriptor>(`${this.basePath}/api/ga4gh/v2/tools/${encodeURIComponent(String(id))}/versions/${encodeURIComponent(String(version_id))}/${encodeURIComponent(String(type))}/descriptor/${encodeURIComponent(String(relative_path))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a list of objects that contain the relative path and file type
     * Get a list of objects that contain the relative path and file type. The descriptors are intended for use with the /tools/{id}/versions/{version_id}/{type}/descriptor/{relative_path : .+} endpoint.
     * @param type The output type of the descriptor. Examples of allowable values are \&quot;CWL\&quot;, \&quot;WDL\&quot;, and \&quot;NextFlow.\&quot;
     * @param id A unique identifier of the tool, scoped to this registry, for example &#x60;123456&#x60;
     * @param version_id An identifier of the tool version for this particular tool registry, for example &#x60;v1&#x60;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolsIdVersionsVersionIdTypeFilesGet(type: string, id: string, version_id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ToolFile>>;
    public toolsIdVersionsVersionIdTypeFilesGet(type: string, id: string, version_id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ToolFile>>>;
    public toolsIdVersionsVersionIdTypeFilesGet(type: string, id: string, version_id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ToolFile>>>;
    public toolsIdVersionsVersionIdTypeFilesGet(type: string, id: string, version_id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling toolsIdVersionsVersionIdTypeFilesGet.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling toolsIdVersionsVersionIdTypeFilesGet.');
        }
        if (version_id === null || version_id === undefined) {
            throw new Error('Required parameter version_id was null or undefined when calling toolsIdVersionsVersionIdTypeFilesGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/plain'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<ToolFile>>(`${this.basePath}/api/ga4gh/v2/tools/${encodeURIComponent(String(id))}/versions/${encodeURIComponent(String(version_id))}/${encodeURIComponent(String(type))}/files`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a list of test JSONs
     * Get a list of test JSONs (these allow you to execute the tool successfully) suitable for use with this descriptor type.
     * @param type The type of the underlying descriptor. Allowable values include \&quot;CWL\&quot;, \&quot;WDL\&quot;, \&quot;NFL\&quot;, \&quot;PLAIN_CWL\&quot;, \&quot;PLAIN_WDL\&quot;, \&quot;PLAIN_NFL\&quot;. For example, \&quot;CWL\&quot; would return an list of ToolTests objects while \&quot;PLAIN_CWL\&quot; would return a bare JSON list with the content of the tests. 
     * @param id A unique identifier of the tool, scoped to this registry, for example &#x60;123456&#x60;
     * @param version_id An identifier of the tool version for this particular tool registry, for example &#x60;v1&#x60;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toolsIdVersionsVersionIdTypeTestsGet(type: string, id: string, version_id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ToolTests>>;
    public toolsIdVersionsVersionIdTypeTestsGet(type: string, id: string, version_id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ToolTests>>>;
    public toolsIdVersionsVersionIdTypeTestsGet(type: string, id: string, version_id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ToolTests>>>;
    public toolsIdVersionsVersionIdTypeTestsGet(type: string, id: string, version_id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling toolsIdVersionsVersionIdTypeTestsGet.');
        }
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling toolsIdVersionsVersionIdTypeTestsGet.');
        }
        if (version_id === null || version_id === undefined) {
            throw new Error('Required parameter version_id was null or undefined when calling toolsIdVersionsVersionIdTypeTestsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json',
            'text/plain'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<ToolTests>>(`${this.basePath}/api/ga4gh/v2/tools/${encodeURIComponent(String(id))}/versions/${encodeURIComponent(String(version_id))}/${encodeURIComponent(String(type))}/tests`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
